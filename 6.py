# Импорт необходимых библиотек
import math  # для математических операций (факториал)
import timeit  # для измерения времени выполнения функций
import pandas as pd  # для работы с таблицами данных
import matplotlib.pyplot as plt  # для визуализации данных


# Рекурсивная реализация функции F(n)
def rec_F(n):
    # Базовые случаи для n = 0 и n = 1
    if n == 0 or n == 1:
        return 3
    # Для n от 2 до 23 используется простая рекурсивная формула
    if n <= 23:
        return (n - 2) * rec_F(n - 1)
    # Для n > 23 применяется более сложная формула с чередованием знаков
    prev = rec_F(n - 1)  # рекурсивный вызов для предыдущего значения
    sign = 1 if n % 2 == 0 else -1  # определение знака в зависимости от четности n
    return sign * (3 - prev / math.factorial(2 * n) - (n - 2))  # комбинированная формула


# Итеративная реализация функции F(n) с оптимизацией вычисления факториала
def iter_F(n):
    # Базовые случаи для n = 0 и n = 1
    if n == 0 or n == 1:
        return 3
    F_prev = 3  # начальное значение (F(1) = 3)
    fact = 2  # начальное значение факториала (2! = 2)
    # Итеративный расчет для n от 2 до заданного значения
    for k in range(2, n + 1):
        # Обновление значения факториала (вычисляется налету для оптимизации)
        fact *= (2 * k - 1) * (2 * k)  # факториал 2k
        # Разные формулы для разных диапазонов k
        if k <= 23:
            F_curr = (k - 2) * F_prev  # простая формула для k ≤ 23
        else:
            sign = 1 if k % 2 == 0 else -1  # определение знака
            F_curr = sign * (3 - F_prev / fact - (k - 2))  # сложная формула для k > 23
        F_prev = F_curr  # обновление предыдущего значения для следующей итерации
    return F_prev  # возвращаем конечный результат


# Основной блок программы
if __name__ == '__main__':
    # Диапазон значений n для тестирования (0-30)
    ns = list(range(0, 31))
    results = []  # список для хранения результатов

    # Измерение времени выполнения для каждого n
    for n in ns:
        # Замер времени для рекурсивной версии (10 запусков)
        t_rec = timeit.timeit(lambda: rec_F(n), number=10)
        # Замер времени для итеративной версии (10 запусков)
        t_it = timeit.timeit(lambda: iter_F(n), number=10)
        results.append((n, t_rec, t_it))  # сохранение результатов

    # Создание DataFrame для удобного отображения результатов
    df = pd.DataFrame(results, columns=['n', 'Recursive Time (s)', 'Iterative Time (s)'])
    print(df.to_string(index=False))  # вывод таблицы без индексов

    # Построение графика сравнения производительности
    plt.figure(figsize=(8, 5))  # размер графика
    plt.plot(df['n'], df['Recursive Time (s)'], '--o', label='Recursive')  # рекурсивная версия
    plt.plot(df['n'], df['Iterative Time (s)'], '-o', label='Iterative')  # итеративная версия
    plt.xlabel('n')  # подпись оси X
    plt.ylabel('Time (s)')  # подпись оси Y
    plt.title('Сравнение времени: рекурсия vs итерация для F(n)')  # заголовок
    plt.legend()  # легенда
    plt.grid(True)  # сетка
    plt.show()  # отображение графика